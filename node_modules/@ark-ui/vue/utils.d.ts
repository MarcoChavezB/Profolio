import { RendererNode, RendererElement, ComputedRef, type AllowedComponentProps, type ComponentCustomProps, type Slots, type VNode, type VNodeProps } from 'vue';
import type { VueProps } from './types';
/**
 * Gets only the valid children of a component,
 * and ignores any nullish or falsy child.
 *
 * @param slots vue slots
 *
 * see https://github.com/vuejs/vue-next/blob/HEAD/packages/runtime-core/src/helpers/renderSlot.ts
 */
export declare function getValidChildren(slots: Slots | null): VNode[];
export type ComponentWithProps<P> = {
    new (): {
        $props: AllowedComponentProps & ComponentCustomProps & VNodeProps & {
            props?: Record<keyof P, any>;
        } & P & {
            [key: string]: unknown;
        };
    };
};
/**
 * Returns a copy of only the valid default slot
 *
 * @param slots - the slots object from the component setup
 * @param componentName component display name for thrown errors
 * @returns A VNode clone of the default slot
 */
export declare function useUniqueChild(slots: Slots, componentName: string): VNode<RendererNode, RendererElement, {
    [key: string]: any;
}>;
/**
 * Generates a unique id
 *
 * @param id external ID provided by consumer/user.
 * @param prefix prefix to append before the id
 */
export declare const useId: (id?: string, prefix?: string) => ComputedRef<string>;
/**
 * For the component composables -- takes in the props object
 * and returns the props with a reactive context object
 */
export declare function transformComposableProps<T extends {
    context: object;
}>(props: T): T;
/**
 * Checks whether a given VNode is a render-vialble element.
 */
export declare function isValidVNodeElement(input: any): boolean;
/**
 * Recursively flattens the Fragment descendants of a given VNode.
 *
 * When you create a component and pass a <slot />, Vue wraps
 * the contents of <slot /> inside a <Fragment /> component and assigns
 * the <slot /> VNode a type of Fragment.
 *
 * So why are we flattening here? Vue renders VNodes from the leaf
 * nodes going up to the root. In other words, when executing the render function
 * of each component, it executes the child render functions first before the parents.
 *
 * This means that at any components render function execution context, all it's children
 * VNodes should have already been rendered -- and that includes any slots! :D
 *
 * In the cases where we pass in a component with slots to the `asChild` component,
 * we shall need to flatten those slot fragment VNodes so as to extract all it's children VNodes
 * to correctly apply the props and event listeners from the with as child components.
 *
 * We do this recursively to ensure that all first child slots that contain fragments in their descendants are rendered into VNodes before passing events.
 * to the first actual element VNode.
 */
export declare function renderSlotFragments(children: VNode[]): VNode[];
export declare function createVueProps<T extends object>(properties: VueProps<T>): VueProps<T>;
export declare const declareEmits: <T extends string>(arr: T[]) => T[];
export declare const generateEventMap: (eventNames: string[], emit: CallableFunction) => Record<string, () => void>;
